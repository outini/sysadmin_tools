#! /usr/bin/env bash

#
# This script comes with no warranty ...use at own risk
# Copyright (C) 2013  Denis Pompilio
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 2 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program or from the site that you downloaded it
# from; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place, Suite 330, Boston, MA  02111-1307   USA
#
# Use this script to schedule "stop" days for your crontasks.
# The default file "default_stop_days.cfg" is used to register
# forbidden days. Specific "stop days" files could be specified
# for running specific crontasks.
#
#

# logfile
LOGFILE="/tmp/parallelrunner.log"

# default values
DEFAULT_N_FORK=50
DEFAULT_SHELL="sh"

SELECTED_HOSTS=

# exit codes
EXIT_USAGE=1
EXIT_DIE=2

# do some cleaning if terminated or interrupted
trap kill_childs TERM INT

_log()
{
    $BATCH || echo "$@"
    echo "`date +%Y%m%d-%H%M%S` $@" >> $LOGFILE
}

uncomment()
{
    # uncomment output and clean empty lines
    # several ways to call it:
    #     uncomment "output"
    #     echo "output" | uncomment
    #     < output_file uncomment

    { [ "$#" -gt 0 ] && echo "$@" || cat - ; } |
    sed -e 's/#.*//;s/[ 	]*$//;/^$/d'
}

show_progressbar()
{
    # progressbar is drawn on 60 columns
    # WARNING: fill must have at least $cols lines
    fill='############################################################'
    cols=60
    cur="${1%%/*}"
    tot="${1##*/}"

    percent=$((cur * cols / tot))

    printf "[%-${cols}.${percent}s] %s\r" "$fill" "$1" >&2
}

prompt_user()
{
    # prompt user with run summary
    # abort process if needed

    cat <<EOF
Running on $total_count selected hosts.
No host output will be displayed here.

Hosts output files can be seen in store directory:
  $STORE

Fork limit is: $N_FORK
Remote shell used is: $SHELL

Filtering criterias are:
       hosts: $HOSTS
       roles: $ROLES
    ip match: $IPMATCH
    id match: $IDMATCH

EOF

    read -p "proceed? [y/N] " answer </dev/tty
    [[ "$answer" =~ ^[yY]([eE][sS])?$ ]] || die "Abort."
}

clean_tempdir()
{
    # clean tempdir if it's still empty
    $store_istemp &&
    [ "$STORE" ] &&
	find "$STORE" -maxdepth 0 -type d -empty -delete
}
die()
{
    _log "$@" >&2
    clean_tempdir
    exit $EXIT_DIE
}

lite_usage()
{
    _log "[ERROR] $*" >&2
    echo "Try --help or -h" >&2
    clean_tempdir
    exit $EXIT_USAGE
}

usage()
{
    cat <<EOF >&2
Usage: $0 [options] <script>
    --hosts host,host,...    specify hosts by IP or name
    --roles role,role,...    specify roles from hostlist to select hosts
    --ipmatch match          specify matches against hostlist's IPs
                             matches could be for example: ^10\.42\.
    --idmatch match          specify matches against hostlist's IDs
                             matches could be for example: ^infra\.mutu[0-2]
    --hostlist file          specify local hostlist file to use
    --fork num               specify how many hosts are parrallelized
                             default is: $DEFAULT_N_FORK
    --shell shell            specify remote shell used to run script
                             default is: $DEFAULT_SHELL
    --store path             the store directory where hosts output files are
                             created. default is generated by 'mktemp -d'
    --sudo                   use sudo to run as root on remote host
    --batch                  proceed in auto mode, supress output
    <script>                 specify local script path to run on remote hosts
                             if "-" is used, script is read from stdin

When running script on remote hosts, the host's number and host's infos are
passed via environment variable: HOST_NUMBER HOST_INFOS

Use of --hosts will deactivate parsing of hostlist and use of options:
    --roles
    --ipmatch
    --idmatch
    --hostlist

If no --hosts, --roles, --idmatch or --ipmatch are used, the entire hostlist
is parsed and all found hosts are processed.

hostlist format should be respected:
    <hostname>:<hostip>:<role>:<ID>:<location>
    etable:10.1.115.2:mysql:cli.mysql-1:vm.sdf.dc.hosting.corp.com

Take care of memory consumption, matching hosts are stored in memory !
EOF

    exit $EXIT_USAGE
}

remoterun()
{
    sshkey_opt=
    [ "$SSH_KEY" ] && sshkey_opt="-i $SSHKEY"
    ssh -oStrictHostKeyChecking=no \
	-oBatchMode=yes \
	-A \
	$sshkey_opt \
        "$@" 2>&1
    #echo "exit status: $?"
}

run_script()
{
    host="$1"
    host_n="$2"

    ## HOST_INFOS is set by parent with infos from hostlist
    $SUDO && cmd="sudo HOST_NUMBER=$host_n HOST_INFOS=$HOST_INFOS $SHELL -" ||
    cmd="HOST_NUMBER=$host_n HOST_INFOS=$HOST_INFOS $SHELL -"

    if [ "$SCRIPT" = "-" ]; then
	echo "$SCRIPT_CONTENT" | remoterun "${host}" "$cmd"
    else
	< "$SCRIPT" remoterun "${host}" "$cmd"
    fi
}

fork()
{
    host="$1"
    n="$2"
    run_script "$host" "$n"
}

slowdown_forks() {
    while [ $N_FORK -lt `ps --no-heading --ppid $$ | wc -l` ]; do
	sleep 1
    done
}

kill_childs()
{
    # if parent process is killed or terminated
    # clean all children

    _log " God's killing kitten..." >&2
    pkill -TERM -P $$
    clean_tempdir
    exit 1
}

check_roles()
{
    # check if host is in given roles
    # roles should be comma separated and not contain any spaces
    host_role="$1"

    ## be careful with word splitting :S
    for role in ${ROLES//,/ }; do
	[ "$host_role" = "$role" ] && return 0
    done

    return 1
}

select_host()
{
    # select host based on required criteria
    # global vars: ROLES, IPMATCH, IDMATCH
    # vars from read file loop: host, role, ip, id, location

    [[ "${host}" =~ ^# ]] && return 1  # ignore comments
    [ -z "$role" ] || [ -z "$ROLES" ] || check_roles "$role" || return 1
    [ -z "$ip" ] || [ -z "$IPMATCH" ] || [[ "$ip" =~ $IPMATCH ]] || return 1
    [ -z "$id" ] || [ -z "$IDMATCH" ] || [[ "$id" =~ $IDMATCH ]] || return 1

    host_infos="$host:$ip:$role:$id:$location"

    SELECTED_HOSTS="$host_infos
$SELECTED_HOSTS"

    return 0
}

read_script()
{
    $BATCH || echo "Reading script from standard input. End with ^D."
    SCRIPT_CONTENT="`cat`"
    $BATCH || echo "--- script content:"
    $BATCH || echo "$SCRIPT_CONTENT"
    $BATCH || echo "---"
}


HOSTS=
ROLES=
IPMATCH=
IDMATCH=
HOSTLIST=
N_FORK=
R_SHELL=
store_istemp=false
STORE=
SSHKEY=
BATCH=false
SUDO=false
SCRIPT=
[ $# -lt 1 ] && lite_usage "not enough arguments"
while [ $# -ge 1 ]; do
    case "$1" in
	--store) STORE="$2"; shift 2 ;;
	--hosts) HOSTS="$2"; shift 2 ;;
	--roles) ROLES="$2"; shift 2 ;;
	--ipmatch) IPMATCH="$2"; shift 2 ;;
	--idmatch) IDMATCH="$2"; shift 2 ;;
	--hostlist) HOSTLIST="$2"; shift 2 ;;
	--fork) N_FORK="$2"; shift 2 ;;
	--shell) SHELL="$2"; shift 2 ;;
	--sshkey) SSHKEY="$2"; shift 2 ;;
	--sudo) SUDO=true; shift ;;
	--batch) BATCH=true; shift ;;
	--help|-h) usage ;;
	*)
	    [ -z "$SCRIPT" ] && SCRIPT="$1" || \
		lite_usage "unknown arg: $1"
	    shift
	    ;;
    esac
done

## checking arguments
[ -z "$HOSTS" ] || \
    echo "$HOSTS" | grep -qi '^[a-z0-9\.-]\+\(,[a-z0-9\.-]\+\)*$' || \
    lite_usage "malformatted --hosts list: $HOSTS"

[ -z "$ROLES" ] || \
    echo "$ROLES" | grep -qi '^[a-z0-9+.]\+\(,[a-z0-9+.]\+\)*$' || \
    lite_usage "malformatted --roles list: $ROLES"

[ -z "$N_FORK" ] && N_FORK="$DEFAULT_N_FORK"
echo "$N_FORK" | grep -q '^[0-9][0-9]*$' || lite_usage "--forks takes number"

[ -z "$SHELL" ] && SHELL="$DEFAULT_SHELL"

[ -z "$HOSTLIST" ] || [ -r "$HOSTLIST" ] || lite_usage "$HOSTLIST not found"

[ -z "$SSHKEY" ] || [ -r "$SSHKEY" ] || lite_usage "ssh key $SSHKEY not found"

[ -z "$STORE" ] && {
	store_istemp=true
	STORE=`mktemp --tmpdir -d pr.XXXXXXXXXX.tmp`
}

[ -d "$STORE" ] || lite_usage "store $STORE does not exists"

$BATCH || tty <&1 >/dev/null || \
    lite_usage "batch mode off and standard input is not a TTY"

if [ "$SCRIPT" = "-" ] ; then
    read_script
else
    [ -r "$SCRIPT" ] || lite_usage "script not found: $SCRIPT"
fi
## END of arguments check

_log "Run: $0 $@"

# select hosts matching criterias
while IFS=: read host ip role id location; do
    select_host
done <<EOF
`
if [ -n "$HOSTS" ]; then
    echo "$HOSTS" | tr ',' '\n'
else
    [ -n "$HOSTLIST" ] && cat "$HOSTLIST" | uncomment
fi
`
EOF


# creating temp log file to store hosts output
logfile=`mktemp`

# store total hosts count for progressbar
total_count=`echo -n "$SELECTED_HOSTS" | wc -l`

# prompt user if not in batch mode
$BATCH || prompt_user

# proceed with the real run
_log "Running $total_count forks..."
_log "Forks limit is $N_FORK"
for host_infos in $SELECTED_HOSTS; do
    slowdown_forks
    : $((count++))

    conn_infos=${host_infos%:*:*:*}
    conn_infos="${conn_infos%:}" # if we have no IP, lets remove the field
    ip=${conn_infos#*:}
    ip="${ip%%,*}" # if we have multiple IPs, use the first
    HOST_INFOS="$host_infos"
    { fork "$ip" "$count" & } > "${STORE%/}/${conn_infos%:*}.log"
    $BATCH || show_progressbar "$count/$total_count"
done

# cleanup the progressbar
$BATCH || echo

_log "All forks have been done."
_log "Waiting for the last children..."

wait
_log "All done."
_log "Log files are stored in $STORE"
